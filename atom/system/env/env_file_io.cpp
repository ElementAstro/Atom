/*
 * env_file_io.cpp
 *
 * Copyright (C) 2023-2024 Max Qian <lightapt.com>
 */

/*************************************************

Date: 2023-12-16

Description: Environment variable file I/O operations implementation

**************************************************/

#include "env_file_io.hpp"

#include <fstream>
#include <sstream>

#include "env_core.hpp"
#include <spdlog/spdlog.h>

namespace atom::utils {

auto EnvFileIO::saveToFile(const std::filesystem::path& filePath,
                           const HashMap<String, String>& vars) -> bool {
    try {
        std::ofstream file(filePath);
        if (!file.is_open()) {
            spdlog::error("Failed to open file for writing: {}",
                          filePath.string());
            return false;
        }

        HashMap<String, String> varsToSave;
        if (vars.empty()) {
            varsToSave = EnvCore::Environ();
        } else {
            varsToSave = vars;
        }

        file << "# Environment variables file\n";
        file << "# Generated by Atom Environment Manager\n";
        file << "# Format: KEY=VALUE\n\n";

        for (const auto& [key, value] : varsToSave) {
            if (isValidKey(key)) {
                file << formatLine(key, value) << '\n';
            } else {
                spdlog::warn("Skipping invalid key: {}", key);
            }
        }

        file.close();
        spdlog::info("Successfully saved {} variables to {}",
                     varsToSave.size(), filePath.string());
        return true;
    } catch (const std::exception& e) {
        spdlog::error("Exception while saving to file: {}", e.what());
        return false;
    }
}

auto EnvFileIO::loadFromFile(const std::filesystem::path& filePath,
                             bool overwrite) -> bool {
    try {
        std::ifstream file(filePath);
        if (!file.is_open()) {
            spdlog::error("Failed to open file for reading: {}",
                          filePath.string());
            return false;
        }

        HashMap<String, String> loadedVars;
        String line;
        int lineNumber = 0;

        while (std::getline(file, line)) {
            lineNumber++;
            
            // Skip empty lines and comments
            if (line.empty() || line[0] == '#') {
                continue;
            }

            auto [key, value] = parseLine(line);
            if (!key.empty()) {
                if (!isValidKey(key)) {
                    spdlog::warn("Invalid key at line {}: {}", lineNumber, key);
                    continue;
                }

                if (!overwrite && !EnvCore::getEnv(key, "").empty()) {
                    spdlog::debug("Skipping existing variable: {}", key);
                    continue;
                }

                loadedVars[key] = value;
            } else {
                spdlog::warn("Failed to parse line {}: {}", lineNumber, line);
            }
        }

        file.close();

        // Set the environment variables
        for (const auto& [key, value] : loadedVars) {
            EnvCore::setEnv(key, value);
        }

        spdlog::info("Successfully loaded {} variables from {}",
                     loadedVars.size(), filePath.string());
        return true;
    } catch (const std::exception& e) {
        spdlog::error("Exception while loading from file: {}", e.what());
        return false;
    }
}

auto EnvFileIO::parseLine(const String& line) -> std::pair<String, String> {
    size_t eq_pos = line.find('=');
    if (eq_pos == String::npos || eq_pos == 0) {
        return {"", ""};
    }

    String key = line.substr(0, eq_pos);
    String value = line.substr(eq_pos + 1);

    // Trim whitespace from key
    size_t start = key.find_first_not_of(" \t");
    size_t end = key.find_last_not_of(" \t");
    if (start != String::npos && end != String::npos) {
        key = key.substr(start, end - start + 1);
    } else {
        return {"", ""};
    }

    // Unescape value
    value = unescapeValue(value);

    return {key, value};
}

auto EnvFileIO::formatLine(const String& key, const String& value) -> String {
    return key + "=" + escapeValue(value);
}

auto EnvFileIO::isValidKey(const String& key) -> bool {
    if (key.empty()) {
        return false;
    }

    // Check if key starts with a letter or underscore
    if (!std::isalpha(key[0]) && key[0] != '_') {
        return false;
    }

    // Check if key contains only alphanumeric characters and underscores
    for (char c : key) {
        if (!std::isalnum(c) && c != '_') {
            return false;
        }
    }

    return true;
}

auto EnvFileIO::escapeValue(const String& value) -> String {
    String escaped;
    escaped.reserve(value.length());

    for (char c : value) {
        switch (c) {
            case '\n':
                escaped += "\\n";
                break;
            case '\r':
                escaped += "\\r";
                break;
            case '\t':
                escaped += "\\t";
                break;
            case '\\':
                escaped += "\\\\";
                break;
            case '"':
                escaped += "\\\"";
                break;
            default:
                escaped += c;
                break;
        }
    }

    // Quote the value if it contains spaces
    if (value.find(' ') != String::npos || value.find('\t') != String::npos) {
        return "\"" + escaped + "\"";
    }

    return escaped;
}

auto EnvFileIO::unescapeValue(const String& value) -> String {
    String unescaped;
    unescaped.reserve(value.length());

    String input = value;
    
    // Remove quotes if present
    if (input.length() >= 2 && input.front() == '"' && input.back() == '"') {
        input = input.substr(1, input.length() - 2);
    }

    for (size_t i = 0; i < input.length(); ++i) {
        if (input[i] == '\\' && i + 1 < input.length()) {
            switch (input[i + 1]) {
                case 'n':
                    unescaped += '\n';
                    ++i;
                    break;
                case 'r':
                    unescaped += '\r';
                    ++i;
                    break;
                case 't':
                    unescaped += '\t';
                    ++i;
                    break;
                case '\\':
                    unescaped += '\\';
                    ++i;
                    break;
                case '"':
                    unescaped += '"';
                    ++i;
                    break;
                default:
                    unescaped += input[i];
                    break;
            }
        } else {
            unescaped += input[i];
        }
    }

    return unescaped;
}

}  // namespace atom::utils
